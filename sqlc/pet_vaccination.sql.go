// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pet_vaccination.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVaccinationsByAdministeredBy = `-- name: CountVaccinationsByAdministeredBy :one
SELECT COUNT(*)
FROM pet_vaccinations
WHERE administered_by = $1
`

func (q *Queries) CountVaccinationsByAdministeredBy(ctx context.Context, administeredBy pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countVaccinationsByAdministeredBy, administeredBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVaccinationsByDateRange = `-- name: CountVaccinationsByDateRange :one
SELECT COUNT(*)
FROM pet_vaccinations
WHERE administered_date BETWEEN $1 AND $2
`

type CountVaccinationsByDateRangeParams struct {
	AdministeredDate   pgtype.Date
	AdministeredDate_2 pgtype.Date
}

func (q *Queries) CountVaccinationsByDateRange(ctx context.Context, arg CountVaccinationsByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVaccinationsByDateRange, arg.AdministeredDate, arg.AdministeredDate_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVaccinationsByPetID = `-- name: CountVaccinationsByPetID :one
SELECT COUNT(*)
FROM pet_vaccinations
WHERE pet_id = $1
`

func (q *Queries) CountVaccinationsByPetID(ctx context.Context, petID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countVaccinationsByPetID, petID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVaccinationsByPetIDs = `-- name: CountVaccinationsByPetIDs :one
SELECT COUNT(*)
FROM pet_vaccinations
WHERE pet_id = ANY($1::int[])
`

func (q *Queries) CountVaccinationsByPetIDs(ctx context.Context, dollar_1 []int32) (int64, error) {
	row := q.db.QueryRow(ctx, countVaccinationsByPetIDs, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPetVaccination = `-- name: CreatePetVaccination :one
INSERT INTO pet_vaccinations(
    pet_id,
    vaccine_name,
    administered_date,
    administered_by,
    notes,
    batch_number,
    next_due_date,
    vaccine_type,
    created_at,
    updated_at
)
VALUES ($1,$2,$3,$4,$5,$6, $7, $8, NOW(), NOW())
RETURNING id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
`

type CreatePetVaccinationParams struct {
	PetID            int32
	VaccineName      string
	AdministeredDate pgtype.Date
	AdministeredBy   pgtype.Int4
	Notes            pgtype.Text
	BatchNumber      pgtype.Text
	NextDueDate      pgtype.Date
	VaccineType      string
}

func (q *Queries) CreatePetVaccination(ctx context.Context, arg CreatePetVaccinationParams) (PetVaccination, error) {
	row := q.db.QueryRow(ctx, createPetVaccination,
		arg.PetID,
		arg.VaccineName,
		arg.AdministeredDate,
		arg.AdministeredBy,
		arg.Notes,
		arg.BatchNumber,
		arg.NextDueDate,
		arg.VaccineType,
	)
	var i PetVaccination
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.VaccineName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.BatchNumber,
		&i.VaccineType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVaccination = `-- name: DeleteVaccination :exec
DELETE FROM pet_vaccinations
WHERE id = $1
`

func (q *Queries) DeleteVaccination(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVaccination, id)
	return err
}

const findAllVaccinationsByPetID = `-- name: FindAllVaccinationsByPetID :many
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE pet_id = $1
ORDER BY administered_date DESC
`

func (q *Queries) FindAllVaccinationsByPetID(ctx context.Context, petID int32) ([]PetVaccination, error) {
	rows, err := q.db.Query(ctx, findAllVaccinationsByPetID, petID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetVaccination
	for rows.Next() {
		var i PetVaccination
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.VaccineName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.BatchNumber,
			&i.VaccineType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByIDAndPetID = `-- name: FindByIDAndPetID :one
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE id = $1 AND pet_id = $2
`

type FindByIDAndPetIDParams struct {
	ID    int32
	PetID int32
}

func (q *Queries) FindByIDAndPetID(ctx context.Context, arg FindByIDAndPetIDParams) (PetVaccination, error) {
	row := q.db.QueryRow(ctx, findByIDAndPetID, arg.ID, arg.PetID)
	var i PetVaccination
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.VaccineName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.BatchNumber,
		&i.VaccineType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findVaccinationByID = `-- name: FindVaccinationByID :one
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE id = $1
`

func (q *Queries) FindVaccinationByID(ctx context.Context, id int32) (PetVaccination, error) {
	row := q.db.QueryRow(ctx, findVaccinationByID, id)
	var i PetVaccination
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.VaccineName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.BatchNumber,
		&i.VaccineType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findVaccinationByIDAndAdministeredBy = `-- name: FindVaccinationByIDAndAdministeredBy :one
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE id = $1 AND administered_by = $2
`

type FindVaccinationByIDAndAdministeredByParams struct {
	ID             int32
	AdministeredBy pgtype.Int4
}

func (q *Queries) FindVaccinationByIDAndAdministeredBy(ctx context.Context, arg FindVaccinationByIDAndAdministeredByParams) (PetVaccination, error) {
	row := q.db.QueryRow(ctx, findVaccinationByIDAndAdministeredBy, arg.ID, arg.AdministeredBy)
	var i PetVaccination
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.VaccineName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.BatchNumber,
		&i.VaccineType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findVaccinationsByAdministeredBy = `-- name: FindVaccinationsByAdministeredBy :many
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE administered_by = $1
ORDER BY administered_date DESC
LIMIT $2 OFFSET $3
`

type FindVaccinationsByAdministeredByParams struct {
	AdministeredBy pgtype.Int4
	Limit          int32
	Offset         int32
}

func (q *Queries) FindVaccinationsByAdministeredBy(ctx context.Context, arg FindVaccinationsByAdministeredByParams) ([]PetVaccination, error) {
	rows, err := q.db.Query(ctx, findVaccinationsByAdministeredBy, arg.AdministeredBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetVaccination
	for rows.Next() {
		var i PetVaccination
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.VaccineName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.BatchNumber,
			&i.VaccineType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findVaccinationsByDateRange = `-- name: FindVaccinationsByDateRange :many
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE administered_date BETWEEN $1 AND $2
ORDER BY administered_date DESC
LIMIT $3 OFFSET $4
`

type FindVaccinationsByDateRangeParams struct {
	AdministeredDate   pgtype.Date
	AdministeredDate_2 pgtype.Date
	Limit              int32
	Offset             int32
}

func (q *Queries) FindVaccinationsByDateRange(ctx context.Context, arg FindVaccinationsByDateRangeParams) ([]PetVaccination, error) {
	rows, err := q.db.Query(ctx, findVaccinationsByDateRange,
		arg.AdministeredDate,
		arg.AdministeredDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetVaccination
	for rows.Next() {
		var i PetVaccination
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.VaccineName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.BatchNumber,
			&i.VaccineType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findVaccinationsByIDAndAdministeredBy = `-- name: FindVaccinationsByIDAndAdministeredBy :one
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations   
WHERE id = $1 AND administered_by = $2
`

type FindVaccinationsByIDAndAdministeredByParams struct {
	ID             int32
	AdministeredBy pgtype.Int4
}

func (q *Queries) FindVaccinationsByIDAndAdministeredBy(ctx context.Context, arg FindVaccinationsByIDAndAdministeredByParams) (PetVaccination, error) {
	row := q.db.QueryRow(ctx, findVaccinationsByIDAndAdministeredBy, arg.ID, arg.AdministeredBy)
	var i PetVaccination
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.VaccineName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.BatchNumber,
		&i.VaccineType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findVaccinationsByPetID = `-- name: FindVaccinationsByPetID :many
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE pet_id = $1
ORDER BY administered_date DESC
LIMIT $2 OFFSET $3
`

type FindVaccinationsByPetIDParams struct {
	PetID  int32
	Limit  int32
	Offset int32
}

func (q *Queries) FindVaccinationsByPetID(ctx context.Context, arg FindVaccinationsByPetIDParams) ([]PetVaccination, error) {
	rows, err := q.db.Query(ctx, findVaccinationsByPetID, arg.PetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetVaccination
	for rows.Next() {
		var i PetVaccination
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.VaccineName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.BatchNumber,
			&i.VaccineType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findVaccinationsByPetIDs = `-- name: FindVaccinationsByPetIDs :many
SELECT id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
FROM pet_vaccinations
WHERE pet_id = ANY($1::int[])
ORDER BY administered_date DESC
LIMIT $2 OFFSET $3
`

type FindVaccinationsByPetIDsParams struct {
	Column1 []int32
	Limit   int32
	Offset  int32
}

func (q *Queries) FindVaccinationsByPetIDs(ctx context.Context, arg FindVaccinationsByPetIDsParams) ([]PetVaccination, error) {
	rows, err := q.db.Query(ctx, findVaccinationsByPetIDs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetVaccination
	for rows.Next() {
		var i PetVaccination
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.VaccineName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.BatchNumber,
			&i.VaccineType,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVaccination = `-- name: UpdateVaccination :one
UPDATE pet_vaccinations
SET
    pet_id = $2,
    vaccine_name = $3,
    administered_date = $4,
    administered_by = $5,
    notes = $6,
    next_due_date = $7,
    batch_number = $8,
    vaccine_type = $9,
    updated_at = NOW()
WHERE id = $1
RETURNING id, pet_id, vaccine_name, administered_date, next_due_date, administered_by, batch_number, vaccine_type, notes, created_at, updated_at
`

type UpdateVaccinationParams struct {
	ID               int32
	PetID            int32
	VaccineName      string
	AdministeredDate pgtype.Date
	AdministeredBy   pgtype.Int4
	Notes            pgtype.Text
	NextDueDate      pgtype.Date
	BatchNumber      pgtype.Text
	VaccineType      string
}

func (q *Queries) UpdateVaccination(ctx context.Context, arg UpdateVaccinationParams) (PetVaccination, error) {
	row := q.db.QueryRow(ctx, updateVaccination,
		arg.ID,
		arg.PetID,
		arg.VaccineName,
		arg.AdministeredDate,
		arg.AdministeredBy,
		arg.Notes,
		arg.NextDueDate,
		arg.BatchNumber,
		arg.VaccineType,
	)
	var i PetVaccination
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.VaccineName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.BatchNumber,
		&i.VaccineType,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
