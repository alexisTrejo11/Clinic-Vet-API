// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: veterinarian.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVeterinarian = `-- name: CreateVeterinarian :one
INSERT INTO veterinarians(
    first_name, last_name, photo, license_number, speciality,
    years_of_experience, is_active, created_at, updated_at, deleted_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, NULL
)
RETURNING
    id, first_name, last_name, photo, license_number, speciality, years_of_experience,
    is_active, user_id, created_at, updated_at, deleted_at
`

type CreateVeterinarianParams struct {
	FirstName         string
	LastName          string
	Photo             string
	LicenseNumber     string
	Speciality        VeterinarianSpeciality
	YearsOfExperience int32
	IsActive          pgtype.Bool
}

func (q *Queries) CreateVeterinarian(ctx context.Context, arg CreateVeterinarianParams) (Veterinarian, error) {
	row := q.db.QueryRow(ctx, createVeterinarian,
		arg.FirstName,
		arg.LastName,
		arg.Photo,
		arg.LicenseNumber,
		arg.Speciality,
		arg.YearsOfExperience,
		arg.IsActive,
	)
	var i Veterinarian
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Photo,
		&i.LicenseNumber,
		&i.Speciality,
		&i.YearsOfExperience,
		&i.IsActive,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getVeterinarianById = `-- name: GetVeterinarianById :one
SELECT 
    id, first_name, last_name, photo, license_number, speciality, years_of_experience, 
    is_active, user_id, created_at, updated_at, deleted_at
FROM veterinarians
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetVeterinarianById(ctx context.Context, id int32) (Veterinarian, error) {
	row := q.db.QueryRow(ctx, getVeterinarianById, id)
	var i Veterinarian
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Photo,
		&i.LicenseNumber,
		&i.Speciality,
		&i.YearsOfExperience,
		&i.IsActive,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listVeterinarians = `-- name: ListVeterinarians :many
SELECT
    id, first_name, last_name, photo, license_number, speciality, years_of_experience, 
    is_active, user_id, created_at, updated_at, deleted_at
FROM
    veterinarians
WHERE
    deleted_at IS NULL
ORDER BY
    CASE WHEN $3 = 'id' AND $4 = 'ASC' THEN id END ASC,
    CASE WHEN $3 = 'id' AND $4 = 'DESC' THEN id END DESC,
    CASE WHEN $3 = 'created_at' AND $4 = 'ASC' THEN created_at END ASC,
    CASE WHEN $3 = 'created_at' AND $4 = 'DESC' THEN created_at END DESC,
    id ASC -- Fallback order if no match
LIMIT $1 OFFSET $2
`

type ListVeterinariansParams struct {
	Limit          int32
	Offset         int32
	OrderBy        interface{}
	OrderDirection interface{}
}

func (q *Queries) ListVeterinarians(ctx context.Context, arg ListVeterinariansParams) ([]Veterinarian, error) {
	rows, err := q.db.Query(ctx, listVeterinarians,
		arg.Limit,
		arg.Offset,
		arg.OrderBy,
		arg.OrderDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Veterinarian
	for rows.Next() {
		var i Veterinarian
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Photo,
			&i.LicenseNumber,
			&i.Speciality,
			&i.YearsOfExperience,
			&i.IsActive,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteVeterinarian = `-- name: SoftDeleteVeterinarian :exec
UPDATE veterinarians
SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteVeterinarian(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteVeterinarian, id)
	return err
}

const updateVeterinarian = `-- name: UpdateVeterinarian :one
UPDATE veterinarians
SET
    first_name = COALESCE($1, first_name),
    last_name = COALESCE($2, last_name),  
    photo = COALESCE($3, photo),          
    license_number = COALESCE($4, license_number),
    speciality = COALESCE($5, speciality),
    years_of_experience = COALESCE($6, years_of_experience),
    is_active = COALESCE($7, is_active),  
    updated_at = CURRENT_TIMESTAMP        
WHERE
    id = $8 AND deleted_at IS NULL       
RETURNING
    id, first_name, last_name, photo, license_number, speciality, years_of_experience,
    is_active, created_at, updated_at, deleted_at
`

type UpdateVeterinarianParams struct {
	FirstName         string
	LastName          string
	Photo             string
	LicenseNumber     string
	Speciality        VeterinarianSpeciality
	YearsOfExperience int32
	IsActive          pgtype.Bool
	ID                int32
}

type UpdateVeterinarianRow struct {
	ID                int32
	FirstName         string
	LastName          string
	Photo             string
	LicenseNumber     string
	Speciality        VeterinarianSpeciality
	YearsOfExperience int32
	IsActive          pgtype.Bool
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	DeletedAt         pgtype.Timestamp
}

func (q *Queries) UpdateVeterinarian(ctx context.Context, arg UpdateVeterinarianParams) (UpdateVeterinarianRow, error) {
	row := q.db.QueryRow(ctx, updateVeterinarian,
		arg.FirstName,
		arg.LastName,
		arg.Photo,
		arg.LicenseNumber,
		arg.Speciality,
		arg.YearsOfExperience,
		arg.IsActive,
		arg.ID,
	)
	var i UpdateVeterinarianRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Photo,
		&i.LicenseNumber,
		&i.Speciality,
		&i.YearsOfExperience,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
