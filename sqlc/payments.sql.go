// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: payments.sql

package sqlc

import (
	"context"

	"clinic-vet-api/db/models"
	"github.com/jackc/pgx/v5/pgtype"
)

const countOverduePayments = `-- name: CountOverduePayments :one
SELECT COUNT (*)
WHERE duedate < CURRENT_TIMESTAMP AND status != 'paid' AND deleted_at IS NULL
`

func (q *Queries) CountOverduePayments(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOverduePayments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentsByCustomerID = `-- name: CountPaymentsByCustomerID :one
SELECT COUNT(*)
FROM payments
WHERE paid_from_customer  = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPaymentsByCustomerID(ctx context.Context, paidFromCustomer pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentsByCustomerID, paidFromCustomer)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentsByDateRange = `-- name: CountPaymentsByDateRange :one
SELECT COUNT(*)
FROM payments
WHERE created_at BETWEEN $1 AND $2 AND deleted_at IS NULL
`

type CountPaymentsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

func (q *Queries) CountPaymentsByDateRange(ctx context.Context, arg CountPaymentsByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentsByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentsByStatus = `-- name: CountPaymentsByStatus :one
SELECT COUNT(*)
FROM payments
WHERE status = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPaymentsByStatus(ctx context.Context, status models.PaymentStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    amount,
    currency,
    status,
    method,
    transaction_id,
    description,
    duedate,
    paid_at,
    refunded_at,
    paid_from_customer,
    paid_to_employee,
    is_active,
    created_at,
    updated_at,
    deleted_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    TRUE,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP,
    NULL
) RETURNING id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
`

type CreatePaymentParams struct {
	Amount           pgtype.Numeric
	Currency         string
	Status           models.PaymentStatus
	Method           models.PaymentMethod
	TransactionID    pgtype.Text
	Description      pgtype.Text
	Duedate          pgtype.Timestamptz
	PaidAt           pgtype.Timestamptz
	RefundedAt       pgtype.Timestamptz
	PaidFromCustomer pgtype.Int4
	PaidToEmployee   pgtype.Int4
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.Method,
		arg.TransactionID,
		arg.Description,
		arg.Duedate,
		arg.PaidAt,
		arg.RefundedAt,
		arg.PaidFromCustomer,
		arg.PaidToEmployee,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Method,
		&i.TransactionID,
		&i.Description,
		&i.Duedate,
		&i.PaidAt,
		&i.RefundedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PaidFromCustomer,
		&i.PaidToEmployee,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
FROM payments
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentByID(ctx context.Context, id int32) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Method,
		&i.TransactionID,
		&i.Description,
		&i.Duedate,
		&i.PaidAt,
		&i.RefundedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PaidFromCustomer,
		&i.PaidToEmployee,
	)
	return i, err
}

const getPaymentByTransactionID = `-- name: GetPaymentByTransactionID :one
SELECT id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
FROM payments
WHERE transaction_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPaymentByTransactionID(ctx context.Context, transactionID pgtype.Text) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByTransactionID, transactionID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Method,
		&i.TransactionID,
		&i.Description,
		&i.Duedate,
		&i.PaidAt,
		&i.RefundedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PaidFromCustomer,
		&i.PaidToEmployee,
	)
	return i, err
}

const listOverduePayments = `-- name: ListOverduePayments :many
SELECT id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
FROM payments
WHERE duedate < CURRENT_TIMESTAMP AND status != 'paid' AND deleted_at IS NULL
ORDER BY duedate ASC
LIMIT $1 OFFSET $2
`

type ListOverduePaymentsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListOverduePayments(ctx context.Context, arg ListOverduePaymentsParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listOverduePayments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.Method,
			&i.TransactionID,
			&i.Description,
			&i.Duedate,
			&i.PaidAt,
			&i.RefundedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PaidFromCustomer,
			&i.PaidToEmployee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByCustomerID = `-- name: ListPaymentsByCustomerID :many
SELECT id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
FROM payments
WHERE paid_from_customer  = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsByCustomerIDParams struct {
	PaidFromCustomer pgtype.Int4
	Limit            int32
	Offset           int32
}

func (q *Queries) ListPaymentsByCustomerID(ctx context.Context, arg ListPaymentsByCustomerIDParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByCustomerID, arg.PaidFromCustomer, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.Method,
			&i.TransactionID,
			&i.Description,
			&i.Duedate,
			&i.PaidAt,
			&i.RefundedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PaidFromCustomer,
			&i.PaidToEmployee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByDateRange = `-- name: ListPaymentsByDateRange :many
SELECT id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
FROM payments
WHERE created_at BETWEEN $1 AND $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListPaymentsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
	Limit       int32
	Offset      int32
}

func (q *Queries) ListPaymentsByDateRange(ctx context.Context, arg ListPaymentsByDateRangeParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.Method,
			&i.TransactionID,
			&i.Description,
			&i.Duedate,
			&i.PaidAt,
			&i.RefundedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PaidFromCustomer,
			&i.PaidToEmployee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByStatus = `-- name: ListPaymentsByStatus :many
SELECT id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
FROM payments
WHERE status = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsByStatusParams struct {
	Status models.PaymentStatus
	Limit  int32
	Offset int32
}

func (q *Queries) ListPaymentsByStatus(ctx context.Context, arg ListPaymentsByStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.Method,
			&i.TransactionID,
			&i.Description,
			&i.Duedate,
			&i.PaidAt,
			&i.RefundedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.PaidFromCustomer,
			&i.PaidToEmployee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeletePayment = `-- name: SoftDeletePayment :exec
UPDATE payments
SET
    is_active = FALSE,
    deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND is_active = TRUE
`

func (q *Queries) SoftDeletePayment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeletePayment, id)
	return err
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE payments
SET
    amount = $1,
    currency = $2,
    status = $3,
    method = $4,
    transaction_id = $5,
    description = $6,
    duedate = $7,
    paid_at = $8,
    refunded_at = $9,
    is_active = $10,
    paid_from_customer = $11,
    paid_to_employee = $12,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $12
RETURNING id, amount, currency, status, method, transaction_id, description, duedate, paid_at, refunded_at, is_active, created_at, updated_at, deleted_at, paid_from_customer, paid_to_employee
`

type UpdatePaymentParams struct {
	Amount           pgtype.Numeric
	Currency         string
	Status           models.PaymentStatus
	Method           models.PaymentMethod
	TransactionID    pgtype.Text
	Description      pgtype.Text
	Duedate          pgtype.Timestamptz
	PaidAt           pgtype.Timestamptz
	RefundedAt       pgtype.Timestamptz
	IsActive         bool
	PaidFromCustomer pgtype.Int4
	PaidToEmployee   pgtype.Int4
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.Method,
		arg.TransactionID,
		arg.Description,
		arg.Duedate,
		arg.PaidAt,
		arg.RefundedAt,
		arg.IsActive,
		arg.PaidFromCustomer,
		arg.PaidToEmployee,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.Method,
		&i.TransactionID,
		&i.Description,
		&i.Duedate,
		&i.PaidAt,
		&i.RefundedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PaidFromCustomer,
		&i.PaidToEmployee,
	)
	return i, err
}
