// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: medical_session.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllMedicalSession = `-- name: CountAllMedicalSession :one
SELECT COUNT(*) FROM medical_sessions
WHERE deleted_at IS NULL
`

func (q *Queries) CountAllMedicalSession(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllMedicalSession)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedicalSessionByCustomerID = `-- name: CountMedicalSessionByCustomerID :one
SELECT COUNT(*) FROM medical_sessions
WHERE customer_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountMedicalSessionByCustomerID(ctx context.Context, customerID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMedicalSessionByCustomerID, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedicalSessionByDateRange = `-- name: CountMedicalSessionByDateRange :one
SELECT COUNT(*) FROM medical_sessions
WHERE visit_date BETWEEN $1 AND $2
AND deleted_at IS NULL
`

type CountMedicalSessionByDateRangeParams struct {
	VisitDate   pgtype.Timestamptz
	VisitDate_2 pgtype.Timestamptz
}

func (q *Queries) CountMedicalSessionByDateRange(ctx context.Context, arg CountMedicalSessionByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMedicalSessionByDateRange, arg.VisitDate, arg.VisitDate_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedicalSessionByDiagnosis = `-- name: CountMedicalSessionByDiagnosis :one
SELECT COUNT(*) FROM medical_sessions
WHERE diagnosis ILIKE '%' || $1 || '%'
AND deleted_at IS NULL
`

func (q *Queries) CountMedicalSessionByDiagnosis(ctx context.Context, dollar_1 pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countMedicalSessionByDiagnosis, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedicalSessionByEmployeeID = `-- name: CountMedicalSessionByEmployeeID :one
SELECT COUNT(*) FROM medical_sessions
WHERE employee_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountMedicalSessionByEmployeeID(ctx context.Context, employeeID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMedicalSessionByEmployeeID, employeeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedicalSessionByPetID = `-- name: CountMedicalSessionByPetID :one
SELECT COUNT(*) FROM medical_sessions
WHERE pet_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountMedicalSessionByPetID(ctx context.Context, petID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMedicalSessionByPetID, petID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const existsMedicalSessionByID = `-- name: ExistsMedicalSessionByID :one
SELECT COUNT(*) > 0 FROM medical_sessions
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) ExistsMedicalSessionByID(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, existsMedicalSessionByID, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const existsMedicalSessionByPetAndDate = `-- name: ExistsMedicalSessionByPetAndDate :one
SELECT COUNT(*) > 0 FROM medical_sessions
WHERE pet_id = $1
AND DATE(visit_date) = DATE($2)
AND deleted_at IS NULL
`

type ExistsMedicalSessionByPetAndDateParams struct {
	PetID int32
	Date  interface{}
}

func (q *Queries) ExistsMedicalSessionByPetAndDate(ctx context.Context, arg ExistsMedicalSessionByPetAndDateParams) (bool, error) {
	row := q.db.QueryRow(ctx, existsMedicalSessionByPetAndDate, arg.PetID, arg.Date)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const findAllMedicalSession = `-- name: FindAllMedicalSession :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $1 OFFSET $2
`

type FindAllMedicalSessionParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) FindAllMedicalSession(ctx context.Context, arg FindAllMedicalSessionParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findAllMedicalSession, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMedicalSessionByCustomerID = `-- name: FindMedicalSessionByCustomerID :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE customer_id = $1 AND deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $2 OFFSET $3
`

type FindMedicalSessionByCustomerIDParams struct {
	CustomerID int32
	Limit      int32
	Offset     int32
}

func (q *Queries) FindMedicalSessionByCustomerID(ctx context.Context, arg FindMedicalSessionByCustomerIDParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findMedicalSessionByCustomerID, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMedicalSessionByDateRange = `-- name: FindMedicalSessionByDateRange :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE visit_date BETWEEN $1 AND $2
AND deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $3 OFFSET $4
`

type FindMedicalSessionByDateRangeParams struct {
	VisitDate   pgtype.Timestamptz
	VisitDate_2 pgtype.Timestamptz
	Limit       int32
	Offset      int32
}

func (q *Queries) FindMedicalSessionByDateRange(ctx context.Context, arg FindMedicalSessionByDateRangeParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findMedicalSessionByDateRange,
		arg.VisitDate,
		arg.VisitDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMedicalSessionByDiagnosis = `-- name: FindMedicalSessionByDiagnosis :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE diagnosis ILIKE '%' || $1 || '%'
AND deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $2 OFFSET $3
`

type FindMedicalSessionByDiagnosisParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

func (q *Queries) FindMedicalSessionByDiagnosis(ctx context.Context, arg FindMedicalSessionByDiagnosisParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findMedicalSessionByDiagnosis, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMedicalSessionByEmployeeID = `-- name: FindMedicalSessionByEmployeeID :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE employee_id = $1 AND deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $2 OFFSET $3
`

type FindMedicalSessionByEmployeeIDParams struct {
	EmployeeID int32
	Limit      int32
	Offset     int32
}

func (q *Queries) FindMedicalSessionByEmployeeID(ctx context.Context, arg FindMedicalSessionByEmployeeIDParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findMedicalSessionByEmployeeID, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMedicalSessionByID = `-- name: FindMedicalSessionByID :one
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) FindMedicalSessionByID(ctx context.Context, id int32) (MedicalSession, error) {
	row := q.db.QueryRow(ctx, findMedicalSessionByID, id)
	var i MedicalSession
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.AppointmentID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.Weight,
		&i.Temperature,
		&i.HeartRate,
		&i.RespiratoryRate,
		&i.Symptoms,
		&i.Medications,
		&i.FollowUpDate,
		&i.IsEmergency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findMedicalSessionByIDAndCustomerID = `-- name: FindMedicalSessionByIDAndCustomerID :one
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE id = $1 AND customer_id = $2 AND deleted_at IS NULL
`

type FindMedicalSessionByIDAndCustomerIDParams struct {
	ID         int32
	CustomerID int32
}

func (q *Queries) FindMedicalSessionByIDAndCustomerID(ctx context.Context, arg FindMedicalSessionByIDAndCustomerIDParams) (MedicalSession, error) {
	row := q.db.QueryRow(ctx, findMedicalSessionByIDAndCustomerID, arg.ID, arg.CustomerID)
	var i MedicalSession
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.AppointmentID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.Weight,
		&i.Temperature,
		&i.HeartRate,
		&i.RespiratoryRate,
		&i.Symptoms,
		&i.Medications,
		&i.FollowUpDate,
		&i.IsEmergency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findMedicalSessionByIDAndEmployeeID = `-- name: FindMedicalSessionByIDAndEmployeeID :one
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE id = $1 AND employee_id = $2 AND deleted_at IS NULL
`

type FindMedicalSessionByIDAndEmployeeIDParams struct {
	ID         int32
	EmployeeID int32
}

func (q *Queries) FindMedicalSessionByIDAndEmployeeID(ctx context.Context, arg FindMedicalSessionByIDAndEmployeeIDParams) (MedicalSession, error) {
	row := q.db.QueryRow(ctx, findMedicalSessionByIDAndEmployeeID, arg.ID, arg.EmployeeID)
	var i MedicalSession
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.AppointmentID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.Weight,
		&i.Temperature,
		&i.HeartRate,
		&i.RespiratoryRate,
		&i.Symptoms,
		&i.Medications,
		&i.FollowUpDate,
		&i.IsEmergency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findMedicalSessionByIDAndPetID = `-- name: FindMedicalSessionByIDAndPetID :one
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE id = $1 AND pet_id = $2 AND deleted_at IS NULL
`

type FindMedicalSessionByIDAndPetIDParams struct {
	ID    int32
	PetID int32
}

func (q *Queries) FindMedicalSessionByIDAndPetID(ctx context.Context, arg FindMedicalSessionByIDAndPetIDParams) (MedicalSession, error) {
	row := q.db.QueryRow(ctx, findMedicalSessionByIDAndPetID, arg.ID, arg.PetID)
	var i MedicalSession
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.AppointmentID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.Weight,
		&i.Temperature,
		&i.HeartRate,
		&i.RespiratoryRate,
		&i.Symptoms,
		&i.Medications,
		&i.FollowUpDate,
		&i.IsEmergency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findMedicalSessionByPetAndDateRange = `-- name: FindMedicalSessionByPetAndDateRange :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE pet_id = $1
AND visit_date BETWEEN $2 AND $3
AND deleted_at IS NULL
ORDER BY visit_date DESC
`

type FindMedicalSessionByPetAndDateRangeParams struct {
	PetID       int32
	VisitDate   pgtype.Timestamptz
	VisitDate_2 pgtype.Timestamptz
}

func (q *Queries) FindMedicalSessionByPetAndDateRange(ctx context.Context, arg FindMedicalSessionByPetAndDateRangeParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findMedicalSessionByPetAndDateRange, arg.PetID, arg.VisitDate, arg.VisitDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMedicalSessionByPetID = `-- name: FindMedicalSessionByPetID :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE pet_id = $1 AND deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $2 OFFSET $3
`

type FindMedicalSessionByPetIDParams struct {
	PetID  int32
	Limit  int32
	Offset int32
}

func (q *Queries) FindMedicalSessionByPetID(ctx context.Context, arg FindMedicalSessionByPetIDParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findMedicalSessionByPetID, arg.PetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRecentMedicalSessionByPetID = `-- name: FindRecentMedicalSessionByPetID :many
SELECT id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at FROM medical_sessions
WHERE pet_id = $1 AND deleted_at IS NULL
ORDER BY visit_date DESC
LIMIT $2
`

type FindRecentMedicalSessionByPetIDParams struct {
	PetID int32
	Limit int32
}

func (q *Queries) FindRecentMedicalSessionByPetID(ctx context.Context, arg FindRecentMedicalSessionByPetIDParams) ([]MedicalSession, error) {
	rows, err := q.db.Query(ctx, findRecentMedicalSessionByPetID, arg.PetID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalSession
	for rows.Next() {
		var i MedicalSession
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.CustomerID,
			&i.EmployeeID,
			&i.AppointmentID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.Weight,
			&i.Temperature,
			&i.HeartRate,
			&i.RespiratoryRate,
			&i.Symptoms,
			&i.Medications,
			&i.FollowUpDate,
			&i.IsEmergency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteMedicalSession = `-- name: HardDeleteMedicalSession :exec
DELETE FROM medical_sessions
WHERE id = $1
`

func (q *Queries) HardDeleteMedicalSession(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, hardDeleteMedicalSession, id)
	return err
}

const saveMedicalSession = `-- name: SaveMedicalSession :one
INSERT INTO medical_sessions (
    pet_id, 
    customer_id,
    employee_id,
    visit_date,
    visit_type,
    diagnosis, 
    treatment,
    notes,
    condition,
    weight,
    temperature,
    heart_rate,
    respiratory_rate
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at
`

type SaveMedicalSessionParams struct {
	PetID           int32
	CustomerID      int32
	EmployeeID      int32
	VisitDate       pgtype.Timestamptz
	VisitType       string
	Diagnosis       pgtype.Text
	Treatment       pgtype.Text
	Notes           pgtype.Text
	Condition       pgtype.Text
	Weight          pgtype.Numeric
	Temperature     pgtype.Numeric
	HeartRate       pgtype.Int4
	RespiratoryRate pgtype.Int4
}

func (q *Queries) SaveMedicalSession(ctx context.Context, arg SaveMedicalSessionParams) (MedicalSession, error) {
	row := q.db.QueryRow(ctx, saveMedicalSession,
		arg.PetID,
		arg.CustomerID,
		arg.EmployeeID,
		arg.VisitDate,
		arg.VisitType,
		arg.Diagnosis,
		arg.Treatment,
		arg.Notes,
		arg.Condition,
		arg.Weight,
		arg.Temperature,
		arg.HeartRate,
		arg.RespiratoryRate,
	)
	var i MedicalSession
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.AppointmentID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.Weight,
		&i.Temperature,
		&i.HeartRate,
		&i.RespiratoryRate,
		&i.Symptoms,
		&i.Medications,
		&i.FollowUpDate,
		&i.IsEmergency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteMedicalSession = `-- name: SoftDeleteMedicalSession :exec
UPDATE medical_sessions
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteMedicalSession(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteMedicalSession, id)
	return err
}

const updateMedicalSession = `-- name: UpdateMedicalSession :one
UPDATE medical_sessions
SET 
    pet_id = $2, 
    customer_id = $3,
    employee_id = $4,
    visit_date = $5, 
    visit_type = $6,
    diagnosis = $7, 
    treatment = $8,
    notes = $9,
    condition = $10,
    weight = $11,
    temperature = $12,
    heart_rate = $13,
    respiratory_rate = $14,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, pet_id, customer_id, employee_id, appointment_id, visit_date, visit_type, diagnosis, notes, treatment, condition, weight, temperature, heart_rate, respiratory_rate, symptoms, medications, follow_up_date, is_emergency, created_at, updated_at, deleted_at
`

type UpdateMedicalSessionParams struct {
	ID              int32
	PetID           int32
	CustomerID      int32
	EmployeeID      int32
	VisitDate       pgtype.Timestamptz
	VisitType       string
	Diagnosis       pgtype.Text
	Treatment       pgtype.Text
	Notes           pgtype.Text
	Condition       pgtype.Text
	Weight          pgtype.Numeric
	Temperature     pgtype.Numeric
	HeartRate       pgtype.Int4
	RespiratoryRate pgtype.Int4
}

func (q *Queries) UpdateMedicalSession(ctx context.Context, arg UpdateMedicalSessionParams) (MedicalSession, error) {
	row := q.db.QueryRow(ctx, updateMedicalSession,
		arg.ID,
		arg.PetID,
		arg.CustomerID,
		arg.EmployeeID,
		arg.VisitDate,
		arg.VisitType,
		arg.Diagnosis,
		arg.Treatment,
		arg.Notes,
		arg.Condition,
		arg.Weight,
		arg.Temperature,
		arg.HeartRate,
		arg.RespiratoryRate,
	)
	var i MedicalSession
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.CustomerID,
		&i.EmployeeID,
		&i.AppointmentID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.Weight,
		&i.Temperature,
		&i.HeartRate,
		&i.RespiratoryRate,
		&i.Symptoms,
		&i.Medications,
		&i.FollowUpDate,
		&i.IsEmergency,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
