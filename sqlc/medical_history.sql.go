// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: medical_history.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMedicalHistory = `-- name: CreateMedicalHistory :one
INSERT INTO medical_history (
    pet_id, 
    owner_id,
    veterinarian_id,
    visit_date,
    visit_type,
    diagnosis, 
    treatment,
    notes,
    condition 
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at
`

type CreateMedicalHistoryParams struct {
	PetID          int32
	OwnerID        int32
	VeterinarianID int32
	VisitDate      pgtype.Timestamptz
	VisitType      string
	Diagnosis      pgtype.Text
	Treatment      pgtype.Text
	Notes          pgtype.Text
	Condition      pgtype.Text
}

func (q *Queries) CreateMedicalHistory(ctx context.Context, arg CreateMedicalHistoryParams) (MedicalHistory, error) {
	row := q.db.QueryRow(ctx, createMedicalHistory,
		arg.PetID,
		arg.OwnerID,
		arg.VeterinarianID,
		arg.VisitDate,
		arg.VisitType,
		arg.Diagnosis,
		arg.Treatment,
		arg.Notes,
		arg.Condition,
	)
	var i MedicalHistory
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.OwnerID,
		&i.VeterinarianID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMedicalHistoryByID = `-- name: GetMedicalHistoryByID :one
SELECT id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at
FROM medical_history
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMedicalHistoryByID(ctx context.Context, id int32) (MedicalHistory, error) {
	row := q.db.QueryRow(ctx, getMedicalHistoryByID, id)
	var i MedicalHistory
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.OwnerID,
		&i.VeterinarianID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMedicalHistoryByOwnerID = `-- name: GetMedicalHistoryByOwnerID :many
SELECT id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at
FROM medical_history
WHERE owner_id = $1 AND deleted_at IS NULL
ORDER BY $2 DESC
OFFSET $3
LIMIT $4
`

type GetMedicalHistoryByOwnerIDParams struct {
	OwnerID int32
	Column2 interface{}
	Offset  int32
	Limit   int32
}

func (q *Queries) GetMedicalHistoryByOwnerID(ctx context.Context, arg GetMedicalHistoryByOwnerIDParams) ([]MedicalHistory, error) {
	rows, err := q.db.Query(ctx, getMedicalHistoryByOwnerID,
		arg.OwnerID,
		arg.Column2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalHistory
	for rows.Next() {
		var i MedicalHistory
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.OwnerID,
			&i.VeterinarianID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteMedicalHistory = `-- name: HardDeleteMedicalHistory :exec
DELETE FROM medical_history
WHERE id = $1
`

func (q *Queries) HardDeleteMedicalHistory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, hardDeleteMedicalHistory, id)
	return err
}

const listMedicalHistoryByPet = `-- name: ListMedicalHistoryByPet :many
SELECT id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at FROM medical_history
WHERE pet_id = $1 AND deleted_at IS NULL
ORDER BY visit_date DESC
`

func (q *Queries) ListMedicalHistoryByPet(ctx context.Context, petID int32) ([]MedicalHistory, error) {
	rows, err := q.db.Query(ctx, listMedicalHistoryByPet, petID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalHistory
	for rows.Next() {
		var i MedicalHistory
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.OwnerID,
			&i.VeterinarianID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMedicalHistoryByVet = `-- name: ListMedicalHistoryByVet :many
SELECT id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at FROM medical_history
WHERE veterinarian_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListMedicalHistoryByVetParams struct {
	VeterinarianID int32
	Limit          int32
	Offset         int32
}

func (q *Queries) ListMedicalHistoryByVet(ctx context.Context, arg ListMedicalHistoryByVetParams) ([]MedicalHistory, error) {
	rows, err := q.db.Query(ctx, listMedicalHistoryByVet, arg.VeterinarianID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalHistory
	for rows.Next() {
		var i MedicalHistory
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.OwnerID,
			&i.VeterinarianID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMedicalHistory = `-- name: SearchMedicalHistory :many
SELECT id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at FROM medical_history
WHERE deleted_at IS NULL
ORDER BY $3 DESC
OFFSET $1
LIMIT $2
`

type SearchMedicalHistoryParams struct {
	Offset  int32
	Limit   int32
	Column3 interface{}
}

func (q *Queries) SearchMedicalHistory(ctx context.Context, arg SearchMedicalHistoryParams) ([]MedicalHistory, error) {
	rows, err := q.db.Query(ctx, searchMedicalHistory, arg.Offset, arg.Limit, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MedicalHistory
	for rows.Next() {
		var i MedicalHistory
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.OwnerID,
			&i.VeterinarianID,
			&i.VisitDate,
			&i.VisitType,
			&i.Diagnosis,
			&i.Notes,
			&i.Treatment,
			&i.Condition,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteMedicalHistory = `-- name: SoftDeleteMedicalHistory :exec
UPDATE medical_history
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteMedicalHistory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteMedicalHistory, id)
	return err
}

const updateMedicalHistory = `-- name: UpdateMedicalHistory :one
UPDATE medical_history
SET 
    pet_id = $2, 
    owner_id = $3,
    veterinarian_id = $4,
    visit_date = $5, 
    diagnosis = $6, 
    visit_type = $7,
    notes = $8,
    condition = $9, 
    treatment = $10, 
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, pet_id, owner_id, veterinarian_id, visit_date, visit_type, diagnosis, notes, treatment, condition, created_at, updated_at, deleted_at
`

type UpdateMedicalHistoryParams struct {
	ID             int32
	PetID          int32
	OwnerID        int32
	VeterinarianID int32
	VisitDate      pgtype.Timestamptz
	Diagnosis      pgtype.Text
	VisitType      string
	Notes          pgtype.Text
	Condition      pgtype.Text
	Treatment      pgtype.Text
}

func (q *Queries) UpdateMedicalHistory(ctx context.Context, arg UpdateMedicalHistoryParams) (MedicalHistory, error) {
	row := q.db.QueryRow(ctx, updateMedicalHistory,
		arg.ID,
		arg.PetID,
		arg.OwnerID,
		arg.VeterinarianID,
		arg.VisitDate,
		arg.Diagnosis,
		arg.VisitType,
		arg.Notes,
		arg.Condition,
		arg.Treatment,
	)
	var i MedicalHistory
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.OwnerID,
		&i.VeterinarianID,
		&i.VisitDate,
		&i.VisitType,
		&i.Diagnosis,
		&i.Notes,
		&i.Treatment,
		&i.Condition,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
