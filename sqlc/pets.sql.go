// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pets.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPetsByCustomerID = `-- name: CountPetsByCustomerID :one
SELECT COUNT(*) FROM pets
WHERE customer_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPetsByCustomerID(ctx context.Context, customerID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countPetsByCustomerID, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPetsBySpecies = `-- name: CountPetsBySpecies :one
SELECT COUNT(*) FROM pets
WHERE species = $1 AND deleted_at IS NULL
`

func (q *Queries) CountPetsBySpecies(ctx context.Context, species string) (int64, error) {
	row := q.db.QueryRow(ctx, countPetsBySpecies, species)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPet = `-- name: CreatePet :one
INSERT INTO pets (
    name, 
    photo, 
    species, 
    breed, 
    age, 
    gender,
    color, 
    microchip, 
    tattoo,
    blood_type,
    is_neutered, 
    customer_id,  
    is_active,
    created_at, 
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING id, name, photo, species, breed, age, gender, color, microchip, tattoo, blood_type, is_neutered, customer_id, is_active, allergies, current_medications, special_needs, feeding_instructions, behavioral_notes, veterinary_contact, emergency_contact_name, emergency_contact_phone, created_at, updated_at, deleted_at
`

type CreatePetParams struct {
	Name       string
	Photo      pgtype.Text
	Species    string
	Breed      pgtype.Text
	Age        pgtype.Int2
	Gender     pgtype.Text
	Color      pgtype.Text
	Microchip  pgtype.Text
	Tattoo     pgtype.Text
	BloodType  pgtype.Text
	IsNeutered pgtype.Bool
	CustomerID int32
	IsActive   bool
}

func (q *Queries) CreatePet(ctx context.Context, arg CreatePetParams) (Pet, error) {
	row := q.db.QueryRow(ctx, createPet,
		arg.Name,
		arg.Photo,
		arg.Species,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.Color,
		arg.Microchip,
		arg.Tattoo,
		arg.BloodType,
		arg.IsNeutered,
		arg.CustomerID,
		arg.IsActive,
	)
	var i Pet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Photo,
		&i.Species,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.Color,
		&i.Microchip,
		&i.Tattoo,
		&i.BloodType,
		&i.IsNeutered,
		&i.CustomerID,
		&i.IsActive,
		&i.Allergies,
		&i.CurrentMedications,
		&i.SpecialNeeds,
		&i.FeedingInstructions,
		&i.BehavioralNotes,
		&i.VeterinaryContact,
		&i.EmergencyContactName,
		&i.EmergencyContactPhone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const existsPetByID = `-- name: ExistsPetByID :one
SELECT COUNT(*) > 0 FROM pets
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) ExistsPetByID(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, existsPetByID, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const existsPetByMicrochip = `-- name: ExistsPetByMicrochip :one
SELECT COUNT(*) > 0 FROM pets
WHERE microchip = $1 AND deleted_at IS NULL
`

func (q *Queries) ExistsPetByMicrochip(ctx context.Context, microchip pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, existsPetByMicrochip, microchip)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const findPetByID = `-- name: FindPetByID :one
SELECT id, name, photo, species, breed, age, gender, color, microchip, tattoo, blood_type, is_neutered, customer_id, is_active, allergies, current_medications, special_needs, feeding_instructions, behavioral_notes, veterinary_contact, emergency_contact_name, emergency_contact_phone, created_at, updated_at, deleted_at FROM pets
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) FindPetByID(ctx context.Context, id int32) (Pet, error) {
	row := q.db.QueryRow(ctx, findPetByID, id)
	var i Pet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Photo,
		&i.Species,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.Color,
		&i.Microchip,
		&i.Tattoo,
		&i.BloodType,
		&i.IsNeutered,
		&i.CustomerID,
		&i.IsActive,
		&i.Allergies,
		&i.CurrentMedications,
		&i.SpecialNeeds,
		&i.FeedingInstructions,
		&i.BehavioralNotes,
		&i.VeterinaryContact,
		&i.EmergencyContactName,
		&i.EmergencyContactPhone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findPetByIDAndCustomerID = `-- name: FindPetByIDAndCustomerID :one
SELECT id, name, photo, species, breed, age, gender, color, microchip, tattoo, blood_type, is_neutered, customer_id, is_active, allergies, current_medications, special_needs, feeding_instructions, behavioral_notes, veterinary_contact, emergency_contact_name, emergency_contact_phone, created_at, updated_at, deleted_at FROM pets
WHERE id = $1 AND customer_id = $2 AND deleted_at IS NULL
`

type FindPetByIDAndCustomerIDParams struct {
	ID         int32
	CustomerID int32
}

func (q *Queries) FindPetByIDAndCustomerID(ctx context.Context, arg FindPetByIDAndCustomerIDParams) (Pet, error) {
	row := q.db.QueryRow(ctx, findPetByIDAndCustomerID, arg.ID, arg.CustomerID)
	var i Pet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Photo,
		&i.Species,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.Color,
		&i.Microchip,
		&i.Tattoo,
		&i.BloodType,
		&i.IsNeutered,
		&i.CustomerID,
		&i.IsActive,
		&i.Allergies,
		&i.CurrentMedications,
		&i.SpecialNeeds,
		&i.FeedingInstructions,
		&i.BehavioralNotes,
		&i.VeterinaryContact,
		&i.EmergencyContactName,
		&i.EmergencyContactPhone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findPetsByCustomerID = `-- name: FindPetsByCustomerID :many
SELECT id, name, photo, species, breed, age, gender, color, microchip, tattoo, blood_type, is_neutered, customer_id, is_active, allergies, current_medications, special_needs, feeding_instructions, behavioral_notes, veterinary_contact, emergency_contact_name, emergency_contact_phone, created_at, updated_at, deleted_at FROM pets
WHERE customer_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type FindPetsByCustomerIDParams struct {
	CustomerID int32
	Limit      int32
	Offset     int32
}

func (q *Queries) FindPetsByCustomerID(ctx context.Context, arg FindPetsByCustomerIDParams) ([]Pet, error) {
	rows, err := q.db.Query(ctx, findPetsByCustomerID, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pet
	for rows.Next() {
		var i Pet
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Photo,
			&i.Species,
			&i.Breed,
			&i.Age,
			&i.Gender,
			&i.Color,
			&i.Microchip,
			&i.Tattoo,
			&i.BloodType,
			&i.IsNeutered,
			&i.CustomerID,
			&i.IsActive,
			&i.Allergies,
			&i.CurrentMedications,
			&i.SpecialNeeds,
			&i.FeedingInstructions,
			&i.BehavioralNotes,
			&i.VeterinaryContact,
			&i.EmergencyContactName,
			&i.EmergencyContactPhone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPetsBySpecies = `-- name: FindPetsBySpecies :many
SELECT id, name, photo, species, breed, age, gender, color, microchip, tattoo, blood_type, is_neutered, customer_id, is_active, allergies, current_medications, special_needs, feeding_instructions, behavioral_notes, veterinary_contact, emergency_contact_name, emergency_contact_phone, created_at, updated_at, deleted_at FROM pets
WHERE species = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type FindPetsBySpeciesParams struct {
	Species string
	Limit   int32
	Offset  int32
}

func (q *Queries) FindPetsBySpecies(ctx context.Context, arg FindPetsBySpeciesParams) ([]Pet, error) {
	rows, err := q.db.Query(ctx, findPetsBySpecies, arg.Species, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pet
	for rows.Next() {
		var i Pet
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Photo,
			&i.Species,
			&i.Breed,
			&i.Age,
			&i.Gender,
			&i.Color,
			&i.Microchip,
			&i.Tattoo,
			&i.BloodType,
			&i.IsNeutered,
			&i.CustomerID,
			&i.IsActive,
			&i.Allergies,
			&i.CurrentMedications,
			&i.SpecialNeeds,
			&i.FeedingInstructions,
			&i.BehavioralNotes,
			&i.VeterinaryContact,
			&i.EmergencyContactName,
			&i.EmergencyContactPhone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeletePet = `-- name: HardDeletePet :exec
DELETE FROM pets WHERE id = $1
`

func (q *Queries) HardDeletePet(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, hardDeletePet, id)
	return err
}

const restorePet = `-- name: RestorePet :exec
UPDATE pets
SET 
    deleted_at = NULL,
    updated_at = CURRENT_TIMESTAMP,
    is_active = TRUE
WHERE id = $1
`

func (q *Queries) RestorePet(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, restorePet, id)
	return err
}

const softDeletePet = `-- name: SoftDeletePet :exec
UPDATE pets
SET 
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP,
    is_active = FALSE
WHERE id = $1
`

func (q *Queries) SoftDeletePet(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeletePet, id)
	return err
}

const updatePet = `-- name: UpdatePet :one
UPDATE pets
SET 
    name = $2,
    photo = $3,
    species = $4,
    breed = $5,
    age = $6,
    gender = $7,
    color = $8,
    microchip = $9,
    is_neutered = $10,
    customer_id = $11,
    tattoo = $12,
    blood_type = $13,
    is_active = $14,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, photo, species, breed, age, gender, color, microchip, tattoo, blood_type, is_neutered, customer_id, is_active, allergies, current_medications, special_needs, feeding_instructions, behavioral_notes, veterinary_contact, emergency_contact_name, emergency_contact_phone, created_at, updated_at, deleted_at
`

type UpdatePetParams struct {
	ID         int32
	Name       string
	Photo      pgtype.Text
	Species    string
	Breed      pgtype.Text
	Age        pgtype.Int2
	Gender     pgtype.Text
	Color      pgtype.Text
	Microchip  pgtype.Text
	IsNeutered pgtype.Bool
	CustomerID int32
	Tattoo     pgtype.Text
	BloodType  pgtype.Text
	IsActive   bool
}

func (q *Queries) UpdatePet(ctx context.Context, arg UpdatePetParams) (Pet, error) {
	row := q.db.QueryRow(ctx, updatePet,
		arg.ID,
		arg.Name,
		arg.Photo,
		arg.Species,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.Color,
		arg.Microchip,
		arg.IsNeutered,
		arg.CustomerID,
		arg.Tattoo,
		arg.BloodType,
		arg.IsActive,
	)
	var i Pet
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Photo,
		&i.Species,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.Color,
		&i.Microchip,
		&i.Tattoo,
		&i.BloodType,
		&i.IsNeutered,
		&i.CustomerID,
		&i.IsActive,
		&i.Allergies,
		&i.CurrentMedications,
		&i.SpecialNeeds,
		&i.FeedingInstructions,
		&i.BehavioralNotes,
		&i.VeterinaryContact,
		&i.EmergencyContactName,
		&i.EmergencyContactPhone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
