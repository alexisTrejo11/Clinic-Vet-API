// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pet_deworm.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPetDewormingsBySpec = `-- name: CountPetDewormingsBySpec :one
SELECT COUNT(*)
FROM pet_deworming 
WHERE 
    ($1::INT IS NULL OR id = $1)
    AND ($2::INT IS NULL OR pet_id = $2)
    AND ($3::INT IS NULL OR administered_by = $3)
    AND ($4::VARCHAR IS NULL OR medication_name ILIKE '%' || $4 || '%')
    AND ($5::DATE IS NULL OR administered_date >= $5)
    AND ($6::DATE IS NULL OR administered_date <= $6)
    AND ($7::DATE IS NULL OR administered_date = $7)
    AND ($8::DATE IS NULL OR next_due_date >= $8)
    AND ($9::DATE IS NULL OR next_due_date <= $9)
    AND ($10::DATE IS NULL OR next_due_date = $10)
    AND ($11::TIMESTAMPTZ IS NULL OR created_at >= $11)
    AND ($12::TIMESTAMPTZ IS NULL OR created_at <= $12)
`

type CountPetDewormingsBySpecParams struct {
	ID                    int32
	PetID                 int32
	AdministeredBy        int32
	MedicationName        string
	AdministeredDateFrom  pgtype.Date
	AdministeredDateTo    pgtype.Date
	AdministeredDateExact pgtype.Date
	NextDueDateFrom       pgtype.Date
	NextDueDateTo         pgtype.Date
	NextDueDateExact      pgtype.Date
	CreatedAtFrom         pgtype.Timestamptz
	CreatedAtTo           pgtype.Timestamptz
}

func (q *Queries) CountPetDewormingsBySpec(ctx context.Context, arg CountPetDewormingsBySpecParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPetDewormingsBySpec,
		arg.ID,
		arg.PetID,
		arg.AdministeredBy,
		arg.MedicationName,
		arg.AdministeredDateFrom,
		arg.AdministeredDateTo,
		arg.AdministeredDateExact,
		arg.NextDueDateFrom,
		arg.NextDueDateTo,
		arg.NextDueDateExact,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPetDeworming = `-- name: CreatePetDeworming :one
INSERT INTO pet_deworming (
    pet_id, medication_name, administered_date, next_due_date, 
    administered_by, notes
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, pet_id, medication_name, administered_date, next_due_date, 
           administered_by, notes, created_at
`

type CreatePetDewormingParams struct {
	PetID            int32
	MedicationName   string
	AdministeredDate pgtype.Date
	NextDueDate      pgtype.Date
	AdministeredBy   pgtype.Int4
	Notes            pgtype.Text
}

func (q *Queries) CreatePetDeworming(ctx context.Context, arg CreatePetDewormingParams) (PetDeworming, error) {
	row := q.db.QueryRow(ctx, createPetDeworming,
		arg.PetID,
		arg.MedicationName,
		arg.AdministeredDate,
		arg.NextDueDate,
		arg.AdministeredBy,
		arg.Notes,
	)
	var i PetDeworming
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.MedicationName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deletePetDeworming = `-- name: DeletePetDeworming :exec
DELETE FROM pet_deworming WHERE id = $1
`

func (q *Queries) DeletePetDeworming(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deletePetDeworming, id)
	return err
}

const findPetDewormingsBySpec = `-- name: FindPetDewormingsBySpec :many
SELECT 
    id, pet_id, medication_name, administered_date, next_due_date,
    administered_by, notes, created_at
FROM pet_deworming 
WHERE 
    ($1::INT IS NULL OR id = $1)
    AND ($2::INT IS NULL OR pet_id = $2)
    AND ($3::INT IS NULL OR administered_by = $3)
    AND ($4::VARCHAR IS NULL OR medication_name ILIKE '%' || $4 || '%')
    AND ($5::DATE IS NULL OR administered_date >= $5)
    AND ($6::DATE IS NULL OR administered_date <= $6)
    AND ($7::DATE IS NULL OR administered_date = $7)
    AND ($8::DATE IS NULL OR next_due_date >= $8)
    AND ($9::DATE IS NULL OR next_due_date <= $9)
    AND ($10::DATE IS NULL OR next_due_date = $10)
    AND ($11::TIMESTAMPTZ IS NULL OR created_at >= $11)
    AND ($12::TIMESTAMPTZ IS NULL OR created_at <= $12)
ORDER BY 
    CASE WHEN $13 = 'administered_date_desc' THEN administered_date END DESC,
    CASE WHEN $13 = 'administered_date_asc' THEN administered_date END ASC,
    CASE WHEN $13 = 'next_due_date_desc' THEN next_due_date END DESC,
    CASE WHEN $13 = 'next_due_date_asc' THEN next_due_date END ASC,
    CASE WHEN $13 = 'created_at_desc' THEN created_at END DESC,
    CASE WHEN $13 = 'created_at_asc' THEN created_at END ASC,
    administered_date DESC -- default ordering
LIMIT $15 OFFSET $14
`

type FindPetDewormingsBySpecParams struct {
	ID                    int32
	PetID                 int32
	AdministeredBy        int32
	MedicationName        string
	AdministeredDateFrom  pgtype.Date
	AdministeredDateTo    pgtype.Date
	AdministeredDateExact pgtype.Date
	NextDueDateFrom       pgtype.Date
	NextDueDateTo         pgtype.Date
	NextDueDateExact      pgtype.Date
	CreatedAtFrom         pgtype.Timestamptz
	CreatedAtTo           pgtype.Timestamptz
	SortBy                interface{}
	OffsetVal             int32
	LimitVal              int32
}

func (q *Queries) FindPetDewormingsBySpec(ctx context.Context, arg FindPetDewormingsBySpecParams) ([]PetDeworming, error) {
	rows, err := q.db.Query(ctx, findPetDewormingsBySpec,
		arg.ID,
		arg.PetID,
		arg.AdministeredBy,
		arg.MedicationName,
		arg.AdministeredDateFrom,
		arg.AdministeredDateTo,
		arg.AdministeredDateExact,
		arg.NextDueDateFrom,
		arg.NextDueDateTo,
		arg.NextDueDateExact,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.SortBy,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetDeworming
	for rows.Next() {
		var i PetDeworming
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.MedicationName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPetDewormingByID = `-- name: GetPetDewormingByID :one
SELECT id, pet_id, medication_name, administered_date, next_due_date, 
       administered_by, notes, created_at
FROM pet_deworming 
WHERE id = $1
`

func (q *Queries) GetPetDewormingByID(ctx context.Context, id int32) (PetDeworming, error) {
	row := q.db.QueryRow(ctx, getPetDewormingByID, id)
	var i PetDeworming
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.MedicationName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getPetDewormingsByPetID = `-- name: GetPetDewormingsByPetID :many
SELECT id, pet_id, medication_name, administered_date, next_due_date, 
       administered_by, notes, created_at
FROM pet_deworming 
WHERE pet_id = $1
ORDER BY administered_date DESC
`

func (q *Queries) GetPetDewormingsByPetID(ctx context.Context, petID int32) ([]PetDeworming, error) {
	rows, err := q.db.Query(ctx, getPetDewormingsByPetID, petID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetDeworming
	for rows.Next() {
		var i PetDeworming
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.MedicationName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingDewormings = `-- name: GetUpcomingDewormings :many
SELECT id, pet_id, medication_name, administered_date, next_due_date, 
       administered_by, notes, created_at
FROM pet_deworming 
WHERE next_due_date IS NOT NULL 
  AND next_due_date <= $1
ORDER BY next_due_date ASC
`

func (q *Queries) GetUpcomingDewormings(ctx context.Context, nextDueDate pgtype.Date) ([]PetDeworming, error) {
	rows, err := q.db.Query(ctx, getUpcomingDewormings, nextDueDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PetDeworming
	for rows.Next() {
		var i PetDeworming
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.MedicationName,
			&i.AdministeredDate,
			&i.NextDueDate,
			&i.AdministeredBy,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePetDeworming = `-- name: UpdatePetDeworming :one
UPDATE pet_deworming 
SET 
    medication_name = COALESCE($2, medication_name),
    administered_date = COALESCE($3, administered_date),
    next_due_date = COALESCE($4, next_due_date),
    administered_by = COALESCE($5, administered_by),
    notes = COALESCE($6, notes)
WHERE id = $1
RETURNING id, pet_id, medication_name, administered_date, next_due_date, 
          administered_by, notes, created_at
`

type UpdatePetDewormingParams struct {
	ID               int32
	MedicationName   string
	AdministeredDate pgtype.Date
	NextDueDate      pgtype.Date
	AdministeredBy   pgtype.Int4
	Notes            pgtype.Text
}

func (q *Queries) UpdatePetDeworming(ctx context.Context, arg UpdatePetDewormingParams) (PetDeworming, error) {
	row := q.db.QueryRow(ctx, updatePetDeworming,
		arg.ID,
		arg.MedicationName,
		arg.AdministeredDate,
		arg.NextDueDate,
		arg.AdministeredBy,
		arg.Notes,
	)
	var i PetDeworming
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.MedicationName,
		&i.AdministeredDate,
		&i.NextDueDate,
		&i.AdministeredBy,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
